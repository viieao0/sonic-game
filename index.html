<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="UTF-8" />
<title>Custom Sonic Engine with Boss & Background</title>
<style>
    body {
        margin: 0;
        background: #87CEEB;
        overflow: hidden;
        font-family: Arial, sans-serif;
    }
    canvas {
        display: block;
        image-rendering: pixelated;
        border: 2px solid black;
        margin: auto;
        position: absolute;
        top: 0; bottom: 0; left: 0; right: 0;
        background: #000; /* fallback background */
    }

    /* Overlay for game over / messages */
    #overlay {
        position: absolute;
        left: 0; right: 0; top: 0; bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
    }
    #overlay .card {
        pointer-events: auto;
        background: rgba(0,0,0,0.75);
        color: white;
        padding: 24px 32px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 6px 18px rgba(0,0,0,0.5);
        transform: scale(0.9);
        opacity: 0;
        transition: transform 180ms ease, opacity 180ms ease;
    }
    #overlay.visible .card {
        transform: scale(1);
        opacity: 1;
    }
    #overlay h1 {
        margin: 0 0 12px 0;
        font-size: 36px;
        color: yellow;
    }
    #overlay p {
        margin: 0 0 16px 0;
        font-size: 16px;
    }
    #overlay button {
        background: #28a745;
        color: white;
        border: none;
        padding: 8px 14px;
        font-size: 16px;
        border-radius: 6px;
        cursor: pointer;
    }
    #overlay button:hover { filter: brightness(1.05); }
    #hint {
        position: absolute;
        left: 12px;
        bottom: 12px;
        color: white;
        font-size: 13px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>

<!-- Overlay element for Game Over / Win messages -->
<div id="overlay" aria-hidden="true">
    <div class="card" role="dialog" aria-modal="true" aria-labelledby="ov-title">
        <h1 id="ov-title">Game Over</h1>
        <p id="ov-text">You lost — hit an obstacle. Press <strong>R</strong> or the Restart button to try again.</p>
        <button id="restartBtn">Restart (R)</button>
    </div>
</div>

<div id="hint">Controls: ← → move • Space jump • X shoot • Z leap</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// Controls
const keys = {};
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

// Also listen for R to restart
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyR') {
        resetGame();
    }
});

// Overlay
const overlay = document.getElementById('overlay');
const restartBtn = document.getElementById('restartBtn');
restartBtn.addEventListener('click', resetGame);

// Player
const sonic = {
    x: 50, y: 120, w: 20, h: 26,
    vx: 0, vy: 0, speed: 4,
    jumpPower: -8, gravity: 0.5,
    grounded: false, facing: 1,
    canLeap: true, leapPower: 6,
    shootCooldown: 0
};

// Platforms
const platforms = [
    {x:0, y:150, w:300, h:100},
    {x:350, y:120, w:80, h:20},
    {x:530, y:150, w:500, h:100},
    {x:1100, y:100, w:100, h:20},
    {x:1300, y:140, w:150, h:20},
];

// Hazards
const hazards = [
    {x:700, y:130, w:20, h:20, type:"mine", dir:1, originalX:700}
];

// Rings
let rings = [
    { x: 200, y: 140, active: true },
    { x: 250, y: 140, active: true },
    { x: 300, y: 140, active: true },
    { x: 800, y: 130, active: true },
    { x: 900, y: 130, active: true },
    { x: 1000, y: 130, active: true },
    { x: 1150, y: 90, active: true },
    { x: 1200, y: 90, active: true },
    { x: 1250, y: 90, active: true },
    { x: 1350, y: 130, active: true },
    { x: 1400, y: 130, active: true },
    { x: 1450, y: 130, active: true }
];

// Regular enemy
const enemy = {
    x: 500, y: 150, w: 20, h: 20,
    vx: 1, leftLimit: 480, rightLimit: 560
};

// Final boss
const boss = {
    x: 1600, y: 80, w: 60, h: 40,
    vx: 1.5, leftLimit: 1400, rightLimit: 1800,
    throwCooldown: 0, hp: 100,
    alive: true,
    falling: false,
    fallVy: 0
};

// Player bullets
let bullets = [];

// Boss explosives
let explosives = [];

let ringsCollected = 0;
let camX = 0;
let gameWon = false;
let gameOver = false; // <-- new flag

// Show loss message (overlay)
function loseGame(reason) {
    if (gameOver || gameWon) return;
    gameOver = true;
    // update message if provided
    if (reason) {
        const txt = document.getElementById('ov-text');
        txt.innerHTML = reason + " <br><strong>Press R or Restart to try again.</strong>";
    }
    overlay.classList.add('visible');
    overlay.setAttribute('aria-hidden', 'false');
}

// Reset the entire game (hide overlay and reset state)
function resetGame() {
    // Hide overlay
    overlay.classList.remove('visible');
    overlay.setAttribute('aria-hidden', 'true');

    // Reset flags
    gameOver = false;
    gameWon = false;

    // Reset Sonic
    sonic.x = 50;
    sonic.y = 120;
    sonic.vx = 0;
    sonic.vy = 0;
    sonic.grounded = false;
    sonic.canLeap = true;
    sonic.shootCooldown = 0;

    // Reset rings
    ringsCollected = 0;
    for (let r of rings) r.active = true;

    // Reset boss
    boss.hp = 100;
    boss.alive = true;
    boss.falling = false;
    boss.x = 1600;
    boss.y = 80;
    boss.fallVy = 0;

    // Clear bullets and explosives
    bullets = [];
    explosives = [];

    // Reset camera
    camX = 0;
}

// Draw background inspired by Green Hill Zone
function drawBackground() {
    // Sky
    ctx.fillStyle = "#0055cc";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Clouds
    ctx.fillStyle = "white";
    for (let i=0; i<5; i++) {
        let cx = (i * 70 - camX * 0.2) % (canvas.width + 60) - 60;
        let cy = 30 + 10 * Math.sin(i + Date.now() * 0.001);
        ctx.beginPath();
        ctx.ellipse(cx, cy, 12, 7, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx+10, cy-5, 15, 9, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(cx+25, cy, 12, 7, 0, 0, Math.PI*2);
        ctx.fill();
    }

    // Ground checker pattern
    const groundY = 150;
    const blockSize = 20;
    for(let x = - (camX % (blockSize*2)); x < canvas.width; x += blockSize){
        for(let y = groundY; y < canvas.height; y += blockSize){
            let checker = (((Math.floor((x+camX)/blockSize) + Math.floor(y/blockSize)) % 2) === 0);
            ctx.fillStyle = checker ? "#A0522D" : "#8B4513";
            ctx.fillRect(x, y, blockSize, blockSize);
        }
    }

    // Grass top
    ctx.fillStyle = "#228B22";
    for(let x = - (camX % 8); x < canvas.width; x += 8){
        ctx.fillRect(x, groundY-6, 4, 6);
    }

    // Palm trees
    const palms = [
        {x: 50, y: groundY-30},
        {x: 180, y: groundY-30},
        {x: 400, y: groundY-30},
        {x: 850, y: groundY-30},
        {x: 1250, y: groundY-30}
    ];

    for(let p of palms){
        let px = p.x - camX;
        if(px < -50 || px > canvas.width+50) continue;
        // trunk
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(px, p.y, 6, 25);
        // leaves
        ctx.fillStyle = "#006400";
        ctx.beginPath(); ctx.moveTo(px+3, p.y); ctx.lineTo(px-10, p.y-15); ctx.lineTo(px+16, p.y-10); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(px+3, p.y-7); ctx.lineTo(px-12, p.y-25); ctx.lineTo(px+15, p.y-25); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(px+3, p.y-15); ctx.lineTo(px-5, p.y-35); ctx.lineTo(px+10, p.y-30); ctx.closePath(); ctx.fill();
    }
}

// Draw Sonic
function drawSonic() {
    ctx.save();
    ctx.translate(sonic.x - camX, sonic.y + sonic.h);
    ctx.scale(sonic.facing, 1);
    ctx.fillStyle = "#0044CC";
    ctx.fillRect(-sonic.w/2, -sonic.h, sonic.w, sonic.h);
    ctx.fillStyle = "#FFD39F";
    ctx.fillRect(-6, -18, 12, 10);
    ctx.fillStyle = "white";
    ctx.fillRect(0, -16, 5, 4);
    ctx.fillStyle = "black";
    ctx.fillRect(3, -15, 2, 2);
    ctx.fillStyle = "#FFD39F";
    ctx.fillRect(-12, -10, 6, 6);
    ctx.fillRect(6, -10, 6, 6);
    ctx.fillStyle = "red";
    ctx.fillRect(-10, 0, 10, 6);
    ctx.fillRect(0, 0, 10, 6);
    ctx.restore();
}

// Draw platforms
function drawPlatforms() {
    ctx.fillStyle = "#228B22";
    for (let p of platforms) {
        ctx.fillRect(p.x - camX, p.y, p.w, p.h);
    }
}

// Draw hazards
function drawHazards() {
    ctx.fillStyle = "darkred";
    for (let h of hazards) {
        ctx.fillRect(h.x - camX, h.y, h.w, h.h);
    }
}

// Draw rings
function drawRings() {
    ctx.strokeStyle = "yellow";
    ctx.lineWidth = 3;
    for (let r of rings) {
        if (!r.active) continue;
        ctx.beginPath();
        ctx.arc(r.x - camX, r.y - 10, 6, 0, Math.PI * 2);
        ctx.stroke();
    }
}

// Draw regular enemy
function drawEnemy() {
    ctx.fillStyle = "darkred";
    ctx.fillRect(enemy.x - camX, enemy.y - enemy.h, enemy.w, enemy.h);
}

// Draw bullets
function drawBullets() {
    ctx.fillStyle = "cyan";
    for (let b of bullets){
        ctx.fillRect(b.x - camX, b.y, 4, 2);
    }
}

// Draw explosives
function drawExplosives() {
    ctx.fillStyle = "orange";
    for(let e of explosives){
        ctx.fillRect(e.x - camX, e.y, 6, 6);
    }
}

// Draw final boss
function drawBoss() {
    if (!boss.alive) return;

    ctx.save();
    ctx.translate(boss.x - camX, boss.y);
    ctx.fillStyle = "purple";
    ctx.fillRect(-boss.w/2, -boss.h, boss.w, boss.h);
    ctx.fillStyle = "red";
    ctx.fillRect(-boss.w/4, -boss.h+10, boss.w/2, 10);
    ctx.restore();
}

// Collect rings
function updateRingCollection() {
    if (gameOver || gameWon) return;
    for (let r of rings) {
        if (!r.active) continue;
        let dx = sonic.x + sonic.w/2 - r.x;
        let dy = sonic.y + sonic.h/2 - r.y;
        if (Math.hypot(dx, dy) < 15) {
            r.active = false;
            ringsCollected++;
        }
    }
}

// Update regular enemy
function updateEnemy() {
    if (gameOver || gameWon) return;
    enemy.x += enemy.vx;
    if (enemy.x < enemy.leftLimit || enemy.x > enemy.rightLimit) enemy.vx *= -1;

    if (Math.abs(sonic.x - enemy.x) < 15 &&
        Math.abs((sonic.y + sonic.h/2) - (enemy.y - enemy.h/2)) < 20) {
        if (sonic.vy > 0) {
            enemy.x = -9999;
            sonic.vy = -5;
        } else {
            loseGame("You hit the enemy!");
        }
    }
}

// Update player
function updatePlayer() {
    if(gameWon || gameOver) return;

    if (keys["ArrowRight"]) { sonic.vx = sonic.speed; sonic.facing = 1; }
    else if (keys["ArrowLeft"])  { sonic.vx = -sonic.speed; sonic.facing = -1; }
    else sonic.vx *= 0.8;

    if ((keys["Space"] || keys["ArrowUp"]) && sonic.grounded) {
        sonic.vy = sonic.jumpPower;
        sonic.grounded = false;
        sonic.canLeap = true;
    }

    if ((keys["KeyZ"] || keys["ShiftLeft"]) && !sonic.grounded && sonic.canLeap) {
        sonic.vx += sonic.facing * sonic.leapPower;
        sonic.canLeap = false;
    }

    if(keys["KeyX"] && sonic.shootCooldown <= 0){
        bullets.push({
            x: sonic.x + sonic.facing*sonic.w/2,
            y: sonic.y - sonic.h/2,
            vx: sonic.facing*10
        });
        sonic.shootCooldown = 10;
    }
    if(sonic.shootCooldown > 0) sonic.shootCooldown--;

    sonic.vy += sonic.gravity;
    sonic.x += sonic.vx;
    sonic.y += sonic.vy;
    sonic.grounded = false;

    for (let p of platforms) {
        if (sonic.x + sonic.w > p.x && sonic.x < p.x + p.w) {
            let nextY = sonic.y + sonic.h;
            if (sonic.vy >= 0 && nextY > p.y && sonic.y + sonic.h - sonic.vy <= p.y) {
                sonic.y = p.y - sonic.h;
                sonic.vy = 0;
                sonic.grounded = true;
            }
        }
    }

    // Collide with mines
    for (let h of hazards) {
        if (sonic.x < h.x + h.w &&
            sonic.x + sonic.w > h.x &&
            sonic.y < h.y + h.h &&
            sonic.y + sonic.h > h.y) {
            loseGame("You hit a mine!");
        }
    }

    if (sonic.y > 300) {
        loseGame("You fell off the map!");
    }
}

// Update moving hazards
function updateHazards() {
    if (gameOver || gameWon) return;
    for (let h of hazards) {
        if (h.type === "mine") {
            h.x += 1.2 * h.dir;
            if (h.x > h.originalX + 50) h.dir = -1;
            if (h.x < h.originalX - 50) h.dir = 1;
        }
    }
}

// Camera
function updateCamera() {
    camX = sonic.x - canvas.width / 2;
    if (camX < 0) camX = 0;
    let maxCamX = 2000 - canvas.width;
    if (camX > maxCamX) camX = maxCamX;
}

// Draw UI / Text
function drawUI() {
    ctx.fillStyle = "white";
    ctx.font = "14px Arial";
    ctx.fillText("Rings: " + ringsCollected, 10, 20);
    if(boss.alive){
        ctx.fillText("Boss HP: " + boss.hp, 10, 40);
    }
    if(gameWon){
        ctx.font = "48px Arial";
        ctx.fillStyle = "yellow";
        ctx.fillText("You Win!", canvas.width/2 - 100, canvas.height/2);
    }
}

// Update bullets
function updateBullets() {
    if(gameWon || gameOver) return;
    for(let i=bullets.length-1;i>=0;i--){
        let b = bullets[i];
        b.x += b.vx;

        if(boss.alive &&
          b.x < boss.x + boss.w && b.x + 4 > boss.x &&
          b.y < boss.y && b.y > boss.y - boss.h){
            boss.hp -= 5;
            bullets.splice(i,1);
            if(boss.hp <= 0){
                boss.alive = false;
                boss.falling = true;
            }
            continue;
        }

        if(b.x < camX || b.x > camX + canvas.width) bullets.splice(i,1);
    }
}

// Update boss
function updateBoss() {
    if(gameWon || gameOver) return;

    if(boss.alive){
        boss.x += boss.vx;
        if(boss.x < boss.leftLimit || boss.x > boss.rightLimit) boss.vx *= -1;

        if(boss.throwCooldown <= 0){
            explosives.push({
                x: boss.x,
                y: boss.y,
                vx: (Math.random()-0.5)*2,
                vy: 4
            });
            boss.throwCooldown = 60;
        } else boss.throwCooldown--;
    }
    else if(boss.falling){
        boss.fallVy += 0.5;
        boss.y += boss.fallVy;
        if(boss.y > 300){
            boss.falling = false;
            gameWon = true;
            // show win overlay too
            const txt = document.getElementById('ov-text');
            txt.innerHTML = "Congratulations! You defeated the boss! Press R to play again.";
            document.getElementById('ov-title').textContent = "You Win!";
            overlay.classList.add('visible');
            overlay.setAttribute('aria-hidden', 'false');
        }
    }
}

// Update explosives
function updateExplosives() {
    if(gameWon || gameOver) return;
    for(let i=explosives.length-1;i>=0;i--){
        let e = explosives[i];
        e.x += e.vx;
        e.y += e.vy;
        e.vy += 0.2;

        if(e.y > canvas.height){
            explosives.splice(i,1);
            continue;
        }

        if(e.x < sonic.x + sonic.w && e.x + 6 > sonic.x &&
           e.y < sonic.y + sonic.h && e.y + 6 > sonic.y){
            explosives.splice(i,1);
            loseGame("Explosion hit you!");
        }
    }
}

// Draw everything
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBackground();
    drawPlatforms();
    drawHazards();
    drawRings();
    drawEnemy();
    drawBullets();
    drawExplosives();
    drawBoss();
    drawSonic();
    drawUI();
}

// Game loop
function gameLoop() {
    updatePlayer();
    updateRingCollection();
    updateEnemy();
    updateHazards();
    updateBullets();
    updateBoss();
    updateExplosives();
    updateCamera();
    draw();
    requestAnimationFrame(gameLoop);
}

// start
gameLoop();
</script>
</body>
</html>
